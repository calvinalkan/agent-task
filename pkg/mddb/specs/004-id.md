# IDs and key encoding

## Caller-supplied IDs

mddb does not generate IDs. The caller MUST supply the document ID when creating, updating, or deleting documents.

The canonical ID is stored in YAML frontmatter under the reserved key `id`. mddb writers inject this field; caller-provided frontmatter MUST NOT include `id`.

## ID specification (IDSpec)

When opening a database, the caller provides an **IDSpec** that defines:

- `KeySize`: size in bytes for slotcache keys (default: 32)
- Validation rules for `id` values
- Encoding from frontmatter `id` → slotcache key bytes

## Frontmatter vs storage representation

The `id` value in frontmatter (human-readable) MAY differ from the encoded key bytes stored in slotcache.

For example:
- Frontmatter: `id: 42`
- Encoded key: `0x000000000000002A` (big-endian uint64)

This allows human-readable IDs while enabling proper binary encoding for sorting.

## Default encoding (UTF-8 string)

The default IDSpec encodes `id` as a UTF-8 string:

1. Take the UTF-8 bytes of `id`
2. Reject if `len(bytes) > KeySize`
3. Copy into a `KeySize` byte array
4. Fill remainder with `0x00` (NUL padding)

With this encoding, keys sort lexicographically as strings. Numeric IDs like `1, 2, 10` will sort as `1, 10, 2` — users must zero-pad (`01, 02, 10`) for correct numeric order.

### Validation (default)

An `id` string MUST satisfy:

- Non-empty
- UTF-8 byte length ≤ `KeySize`
- No NUL bytes (`\x00`)
- No path separators (`/` or `\`)
- No ASCII whitespace (space, tab, newline)

Implementations SHOULD additionally restrict IDs to a conservative ASCII subset suitable for filenames, for example: `A-Z a-z 0-9 . _ - :`

## Alternative encodings (implementation-defined)

Implementations MAY provide alternative IDSpec encodings for different use cases:

| Encoding | Frontmatter | Key bytes | Sort behavior |
|----------|-------------|-----------|---------------|
| UTF-8 string (default) | `id: task-001` | UTF-8 + NUL pad | Lexicographic string |
| Big-endian uint64 | `id: 42` | 8 bytes big-endian | Numeric ascending |
| Padded integer | `id: 42` | `"000042"` UTF-8 | Numeric (as string) |
| UUIDv7 text | `id: 019011dc-...` | UTF-8 | Chronological |
| UUIDv7 binary | `id: 019011dc-...` | 16 bytes binary | Chronological |

The exact encodings available are implementation-defined. The spec only requires that:

- The encoding is deterministic and reversible
- `KeySize` matches the encoded size
- slotcache is configured with the correct `KeySize`

## Ordering and comparison

slotcache sorts keys by **bytewise lexicographic order** of the encoded key bytes. It does not interpret key contents.

Numeric ID encodings use **big-endian** byte order so that bytewise comparison matches numeric order. This enables slotcache's range scans to work correctly on numeric/timestamp-based IDs without decoding.

mddb's ordering behavior depends on the IDSpec encoding:
- UTF-8 string: lexicographic string order
- Big-endian integers: numeric order
- UUIDv7: chronological order

## Equality

IDs are compared by exact equality of their encoded key bytes. Implementations MUST NOT apply Unicode normalization, case-folding, or trimming unless the IDSpec explicitly defines such behavior.
