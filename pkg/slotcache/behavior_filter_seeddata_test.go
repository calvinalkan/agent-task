// Fuzz corpus seed data for filter coverage.
//
// These byte sequences are carefully constructed to exercise filtered scan
// paths in the fuzz decoder. They are shared between the fuzz test (as seeds)
// and a guard test that verifies they still emit filtered scans.
//
// If the decoder's byte consumption changes, these seeds may need updating.
// The guard test (behavior_filter_seed_guard_test.go) will fail if they no
// longer emit any filtered scan operations.

package slotcache_test

// seedBehaviorFilteredScans exercises multiple scan types with different filters.
//
// Sequence:
//  1. BeginWrite -> Put(key1, rev=1) -> Put(key2, rev=2) -> Commit
//  2. Scan with FilterRevisionMask (even revisions)
//  3. Scan with FilterIndexByteEq
//  4. ScanPrefix with FilterAll
var seedBehaviorFilteredScans = []byte{
	// --- Insert test data ---
	0x80, 0x06, // roulette=0x80 (>=26), choice=6 -> BeginWrite

	0x80, 0x00, // roulette=0x80, choice=0 -> Put
	0xFF,                                           // key mode: new valid key
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // key1
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // revision=1 (odd)
	0xFF,                   // index mode: valid
	0x10, 0x00, 0x00, 0x00, // index (0x10 in first byte)

	0x80, 0x00, // Put
	0xFF,
	0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, // key2
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // revision=2 (even)
	0xFF,
	0x10, 0x01, 0x00, 0x00, // index (0x10 in first byte)

	0x80, 0x02, // Commit

	// --- Scan with FilterRevisionMask(mask=1, want=0) -> even revisions ---
	0x80, 0x02, // roulette=0x80, choice=2 -> Scan
	0x02, // nextFilterSpec: 0x02 % 10 = 2 < 3 -> get filter
	0x02, // kind: 0x02 % 5 = 2 -> FilterRevisionMask
	0x00, // mask selector: 0x00 % 4 = 0 -> mask=1
	0x00, // want: 0x00 & 1 = 0 -> want=0 (even revisions)
	0x80, // scanOpts mode >= 26 -> valid
	0x00, // offset=0
	0x00, // limit=0
	0x00, // reverse=false

	// --- Scan with FilterIndexByteEq(offset=0, byte=0x10) ---
	0x80, 0x02, // Scan
	0x01, // nextFilterSpec: 0x01 % 10 = 1 < 3 -> get filter
	0x03, // kind: 0x03 % 5 = 3 -> FilterIndexByteEq
	0x00, // offset: 0x00 % 4 = 0
	0x10, // byte: 0x10
	0x80, // scanOpts valid
	0x00, 0x00, 0x00,

	// --- ScanPrefix with FilterAll ---
	0x80, 0x03, // roulette=0x80, choice=3 -> ScanPrefix
	0xFF, // prefix mode: valid (>=52)
	0x00, // select key index (no keys seen yet in this context, so random)
	0x00, // prefixLen byte
	0x00, // nextFilterSpec: 0x00 % 10 = 0 < 3 -> get filter
	0x00, // kind: 0x00 % 5 = 0 -> FilterAll (actually FilterNone, but 0 maps to FilterNone)
	0x80, // scanOpts valid
	0x00, 0x00, 0x00,
}

// seedBehaviorFilterPagination exercises filter combined with pagination.
//
// Sequence:
//  1. BeginWrite -> Put 4 entries with varying revisions -> Commit
//  2. Scan with FilterRevisionMask + Offset=1, Limit=1
var seedBehaviorFilterPagination = []byte{
	// --- Insert 4 entries ---
	0x80, 0x06, // BeginWrite

	0x80, 0x00, // Put key1, rev=1
	0xFF,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xA0, 0x00, 0x00, 0x00,

	0x80, 0x00, // Put key2, rev=2
	0xFF,
	0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xB0, 0x00, 0x00, 0x00,

	0x80, 0x00, // Put key3, rev=3
	0xFF,
	0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xC0, 0x00, 0x00, 0x00,

	0x80, 0x00, // Put key4, rev=4
	0xFF,
	0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xD0, 0x00, 0x00, 0x00,

	0x80, 0x02, // Commit

	// --- Scan with FilterRevisionMask(mask=1, want=0) + pagination ---
	// This filters to even revisions (2, 4), then applies offset=1, limit=1
	0x80, 0x02, // Scan
	0x00, // nextFilterSpec: get filter
	0x02, // FilterRevisionMask
	0x00, // mask=1
	0x00, // want=0 (even)
	0x80, // scanOpts valid
	0x01, // offset=1 (skip first match)
	0x01, // limit=1
	0x00, // reverse=false
}
