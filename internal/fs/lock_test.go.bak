package fs

import (
	"errors"
	"fmt"
	"math"
	"os"
	"path/filepath"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

const testTimeout = 2 * time.Second

// -----------------------------------------------------------------------------
// Lock() Tests
// -----------------------------------------------------------------------------

// TestLock_AcquireAndRelease verifies basic lock acquire/release works.
func TestLock_AcquireAndRelease(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")

	lock, err := locker.Lock(path, testTimeout)

	if got, want := err, error(nil); !errors.Is(got, want) {
		t.Fatalf("Lock err=%v, want=%v", got, want)
	}

	if got, want := lock.Close(), error(nil); !errors.Is(got, want) {
		t.Fatalf("Close err=%v, want=%v", got, want)
	}
}

// TestLock_SecondLockBlocks verifies that a second lock on the same
// path blocks until the first is released.
func TestLock_SecondLockBlocks(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")

	// Acquire first lock
	lock1, err := locker.Lock(path, testTimeout)
	if err != nil {
		t.Fatalf("first Lock err=%v, want=nil", err)
	}

	// Try to acquire second lock in goroutine
	var (
		lock2     *Lock
		lock2Err  error
		lock2Time time.Time
	)

	done := make(chan struct{})

	go func() {
		lock2, lock2Err = locker.Lock(path, testTimeout)
		lock2Time = time.Now()

		close(done)
	}()

	// Wait a bit to ensure goroutine is blocked
	time.Sleep(100 * time.Millisecond)

	// Release first lock
	releaseTime := time.Now()

	lock1.Close()

	// Wait for second lock to acquire
	select {
	case <-done:
		// Good - second lock acquired
	case <-time.After(3 * time.Second):
		t.Fatal("second Lock should acquire after first is released")
	}

	if got, want := lock2Err, error(nil); !errors.Is(got, want) {
		t.Fatalf("second Lock err=%v, want=%v", got, want)
	}

	// Verify second lock acquired AFTER first was released
	if got, want := lock2Time.After(releaseTime), true; got != want {
		t.Fatal("second lock should acquire after first is released")
	}

	lock2.Close()
}

// TestLock_CanReacquireAfterRelease verifies that after releasing a lock,
// it can be acquired again (no deadlock or leaked state).
func TestLock_CanReacquireAfterRelease(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")

	// Acquire and release multiple times
	for i := range 3 {
		lock, err := locker.Lock(path, testTimeout)
		if got, want := err, error(nil); !errors.Is(got, want) {
			t.Fatalf("attempt %d: Lock err=%v, want=%v", i, got, want)
		}

		lock.Close()
	}
}

// TestLock_DifferentPathsIndependent verifies that locks on different
// paths don't interfere with each other.
func TestLock_DifferentPathsIndependent(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path1 := filepath.Join(dir, "file1.txt")
	path2 := filepath.Join(dir, "file2.txt")

	// Acquire lock on path1
	lock1, err := locker.Lock(path1, testTimeout)
	if got, want := err, error(nil); !errors.Is(got, want) {
		t.Fatalf("Lock(path1) err=%v, want=%v", got, want)
	}
	defer lock1.Close()

	// Should be able to acquire lock on path2 immediately
	lock2, err := locker.Lock(path2, testTimeout)
	if got, want := err, error(nil); !errors.Is(got, want) {
		t.Fatalf("Lock(path2) err=%v, want=%v", got, want)
	}
	defer lock2.Close()
}

// TestLock_CreatesLocksDirectory verifies that Lock() creates the
// .locks subdirectory if it doesn't exist.
func TestLock_CreatesLocksDirectory(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")
	locksDir := filepath.Join(dir, ".locks")

	// Verify .locks doesn't exist yet
	if _, err := os.Stat(locksDir); !os.IsNotExist(err) {
		t.Fatal(".locks should not exist before Lock()")
	}

	// Acquire lock
	lock, err := locker.Lock(path, testTimeout)
	if got, want := err, error(nil); !errors.Is(got, want) {
		t.Fatalf("Lock err=%v, want=%v", got, want)
	}
	defer lock.Close()

	// Verify .locks was created
	if _, err := os.Stat(locksDir); err != nil {
		t.Fatalf(".locks should exist after Lock(), err=%v", err)
	}
}

// TestLock_SurvivesLockFileDeletion verifies that if the lock file is
// deleted while waiting for the lock, Lock() retries and still acquires it.
//
// This tests the inode verification logic:
//  1. Process A opens lock file (inode 123)
//  2. Process A waits for flock
//  3. Process B deletes the lock file
//  4. Process C creates new lock file (inode 456)
//  5. Process A acquires flock, but inode changed! Must retry.
func TestLock_SurvivesLockFileDeletion(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")
	locksDir := filepath.Join(dir, ".locks")
	lockPath := filepath.Join(locksDir, "data.txt.lock")

	// Acquire first lock
	lock1, err := locker.Lock(path, testTimeout)
	if got, want := err, error(nil); !errors.Is(got, want) {
		t.Fatalf("first Lock err=%v, want=%v", got, want)
	}

	// Start goroutine that will wait for lock
	lock2Done := make(chan struct{})

	var (
		lock2    *Lock
		lock2Err error
	)

	go func() {
		lock2, lock2Err = locker.Lock(path, testTimeout)

		close(lock2Done)
	}()

	// Give goroutine time to start waiting
	time.Sleep(50 * time.Millisecond)

	// Delete the lock file while goroutine is waiting!
	// This simulates the race condition the inode check protects against.
	os.Remove(lockPath)

	// Release first lock
	lock1.Close()

	// Second lock should still succeed (after retry)
	select {
	case <-lock2Done:
		if got, want := lock2Err, error(nil); !errors.Is(got, want) {
			t.Fatalf("second Lock err=%v, want=%v", got, want)
		}

		lock2.Close()
	case <-time.After(3 * time.Second):
		t.Fatal("second Lock should succeed after lock file deletion + retry")
	}
}

// TestLock_SurvivesLockFileReplacement verifies that if the lock file is
// replaced (deleted + recreated) while waiting, Lock() retries correctly.
func TestLock_SurvivesLockFileReplacement(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")
	locksDir := filepath.Join(dir, ".locks")
	lockPath := filepath.Join(locksDir, "data.txt.lock")

	// Acquire first lock
	lock1, err := locker.Lock(path, testTimeout)
	if got, want := err, error(nil); !errors.Is(got, want) {
		t.Fatalf("first Lock err=%v, want=%v", got, want)
	}

	// Start goroutine that will wait for lock
	lock2Done := make(chan struct{})

	var (
		lock2    *Lock
		lock2Err error
	)

	go func() {
		lock2, lock2Err = locker.Lock(path, testTimeout)

		close(lock2Done)
	}()

	// Give goroutine time to start waiting
	time.Sleep(50 * time.Millisecond)

	// Delete AND recreate the lock file - this changes the inode!
	os.Remove(lockPath)
	os.WriteFile(lockPath, []byte{}, 0644) // New inode

	// Release first lock
	lock1.Close()

	// Second lock should still succeed (detects inode change, retries)
	select {
	case <-lock2Done:
		if got, want := lock2Err, error(nil); !errors.Is(got, want) {
			t.Fatalf("second Lock err=%v, want=%v", got, want)
		}

		lock2.Close()
	case <-time.After(3 * time.Second):
		t.Fatal("second Lock should succeed after lock file replacement + retry")
	}
}

// TestLock_TimeoutWhenContended verifies that Lock() returns
// ErrDeadlineExceeded when it can't acquire the lock within the timeout.
func TestLock_TimeoutWhenContended(t *testing.T) {
	// Skip in short mode - this test waits for timeout
	if testing.Short() {
		t.Skip("skipping timeout test in short mode")
	}

	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")

	// Acquire lock and hold it
	lock1, err := locker.Lock(path, testTimeout)
	if got, want := err, error(nil); !errors.Is(got, want) {
		t.Fatalf("first Lock err=%v, want=%v", got, want)
	}
	defer lock1.Close()

	// Try to acquire second lock with short timeout - should timeout
	start := time.Now()
	_, err = locker.Lock(path, 500*time.Millisecond)
	elapsed := time.Since(start)

	if got, want := err, os.ErrDeadlineExceeded; !errors.Is(got, want) {
		t.Fatalf("err=%v, want=%v", got, want)
	}

	// Should have waited approximately 500ms
	if got, want := elapsed >= 400*time.Millisecond, true; got != want {
		t.Fatalf("elapsed=%v, want at least 400ms", elapsed)
	}
}

// TestLock_NonBlockingFailsImmediately verifies that Lock() with timeout=0
// fails immediately if the lock is held.
func TestLock_NonBlockingFailsImmediately(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")

	// Acquire lock and hold it
	lock1, err := locker.Lock(path, testTimeout)
	if got, want := err, error(nil); !errors.Is(got, want) {
		t.Fatalf("first Lock err=%v, want=%v", got, want)
	}
	defer lock1.Close()

	// Try to acquire second lock with timeout=0 (non-blocking)
	start := time.Now()
	_, err = locker.Lock(path, 0)
	elapsed := time.Since(start)

	// Should fail (EWOULDBLOCK or similar)
	if err == nil {
		t.Fatal("non-blocking Lock should fail when contended")
	}

	// Should fail quickly (< 100ms)
	if got, want := elapsed < 100*time.Millisecond, true; got != want {
		t.Fatalf("elapsed=%v, want < 100ms for non-blocking", elapsed)
	}
}

// TestLock_PathReturnsLockFilePath verifies that Path() returns the lock file path.
func TestLock_PathReturnsLockFilePath(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")

	lock, err := locker.Lock(path, testTimeout)
	if err != nil {
		t.Fatalf("Lock err=%v", err)
	}
	defer lock.Close()

	expected := filepath.Join(dir, ".locks", "data.txt.lock")
	if got, want := lock.Path(), expected; got != want {
		t.Fatalf("Path()=%q, want=%q", got, want)
	}
}

// -----------------------------------------------------------------------------
// RLock() Tests
// -----------------------------------------------------------------------------

// TestRLock_MultipleReadersAllowed verifies multiple shared locks can be held.
func TestRLock_MultipleReadersAllowed(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")

	// Acquire multiple read locks - should all succeed
	lock1, err := locker.RLock(path, testTimeout)
	if err != nil {
		t.Fatalf("first RLock err=%v", err)
	}
	defer lock1.Close()

	lock2, err := locker.RLock(path, testTimeout)
	if err != nil {
		t.Fatalf("second RLock err=%v", err)
	}
	defer lock2.Close()

	lock3, err := locker.RLock(path, testTimeout)
	if err != nil {
		t.Fatalf("third RLock err=%v", err)
	}
	defer lock3.Close()
}

// TestRLock_BlocksExclusiveLock verifies a read lock blocks exclusive locks.
func TestRLock_BlocksExclusiveLock(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")

	// Acquire read lock
	rlock, err := locker.RLock(path, testTimeout)
	if err != nil {
		t.Fatalf("RLock err=%v", err)
	}
	defer rlock.Close()

	// Try exclusive lock with short timeout - should fail
	_, err = locker.Lock(path, 100*time.Millisecond)
	if err == nil {
		t.Fatal("exclusive Lock should be blocked by read lock")
	}
}

// TestLock_BlocksReadLock verifies an exclusive lock blocks read locks.
func TestLock_BlocksReadLock(t *testing.T) {
	fs := NewReal()
	locker := NewLocker(fs)
	dir := t.TempDir()
	path := filepath.Join(dir, "data.txt")

	// Acquire exclusive lock
	lock, err := locker.Lock(path, testTimeout)
	if err != nil {
		t.Fatalf("Lock err=%v", err)
	}
	defer lock.Close()

	// Try read lock with short timeout - should fail
	_, err = locker.RLock(path, 100*time.Millisecond)
	if err == nil {
		t.Fatal("RLock should be blocked by exclusive lock")
	}
}

// -----------------------------------------------------------------------------
// Lock() Fuzz Tests
// -----------------------------------------------------------------------------

// FuzzLock_MutualExclusion verifies two goroutines cannot hold the same lock
// simultaneously.
func FuzzLock_MutualExclusion(f *testing.F) {
	// Boundary values (test clamping logic)
	f.Add(int64(0), 2, 1)     // Minimum valid (after clamping)
	f.Add(int64(1), 10, 20)   // Maximum valid (after clamping)
	f.Add(int64(2), 1, 0)     // Below minimum (tests clamping)
	f.Add(int64(3), 100, 100) // Above maximum (tests clamping)

	// High contention scenarios
	f.Add(int64(100), 10, 10) // Max goroutines, medium iterations
	f.Add(int64(101), 5, 20)  // Medium goroutines, max iterations

	// Seed boundaries
	f.Add(int64(-1), 5, 10)
	f.Add(int64(math.MaxInt64), 5, 10)

	f.Fuzz(func(t *testing.T, seed int64, goroutines int, iterations int) {
		// Bound inputs to reasonable ranges
		if goroutines < 2 {
			goroutines = 2
		}

		if goroutines > 10 {
			goroutines = 10
		}

		if iterations < 1 {
			iterations = 1
		}

		if iterations > 20 {
			iterations = 20
		}

		fs := NewReal()
		locker := NewLocker(fs)
		dir := t.TempDir()
		path := filepath.Join(dir, "data.txt")

		// Shared counter - if mutual exclusion works, final value is predictable
		var (
			counter   int
			counterMu sync.Mutex
		)

		// Track if anyone is in critical section
		var inCritical atomic.Int32

		var wg sync.WaitGroup

		errs := make(chan error, goroutines*iterations)

		for g := range goroutines {
			wg.Add(1)

			go func(id int) {
				defer wg.Done()

				for range iterations {
					lock, err := locker.Lock(path, 5*time.Second)
					if err != nil {
						errs <- fmt.Errorf("goroutine %d: Lock failed: %w", id, err)

						return
					}

					// No one else should be in critical section
					if got, want := inCritical.Add(1), int32(1); got != want {
						errs <- fmt.Errorf("goroutine %d: inCritical=%d, want=%d (mutual exclusion violated)", id, got, want)

						lock.Close()

						return
					}

					// Critical section - increment counter
					counterMu.Lock()

					counter++

					counterMu.Unlock()

					// Small sleep to increase chance of race detection
					time.Sleep(time.Microsecond * 10)

					inCritical.Add(-1)
					lock.Close()
				}
			}(g)
		}

		wg.Wait()
		close(errs)

		// Check for errors
		for err := range errs {
			t.Fatal(err)
		}

		// Counter should equal total iterations
		if got, want := counter, goroutines*iterations; got != want {
			t.Fatalf("counter=%d, want=%d (lost updates = broken mutex)", got, want)
		}
	})
}

// FuzzLock_NoDeadlock verifies acquire+release cycles always complete (no
// deadlock).
func FuzzLock_NoDeadlock(f *testing.F) {
	// Boundary cycles (tests clamping)
	f.Add(int64(0), 1)   // Minimum
	f.Add(int64(1), 100) // Maximum
	f.Add(int64(2), 0)   // Below min (clamped to 1)
	f.Add(int64(3), 200) // Above max (clamped to 100)

	// Seed boundaries
	f.Add(int64(-1), 50)
	f.Add(int64(math.MaxInt64), 50)

	f.Fuzz(func(t *testing.T, seed int64, cycles int) {
		if cycles < 1 {
			cycles = 1
		}

		if cycles > 100 {
			cycles = 100
		}

		fs := NewReal()
		locker := NewLocker(fs)
		dir := t.TempDir()
		path := filepath.Join(dir, "data.txt")

		done := make(chan struct{})

		go func() {
			for range cycles {
				lock, err := locker.Lock(path, testTimeout)
				if err != nil {
					return // Lock timeout is OK
				}

				lock.Close()
			}

			close(done)
		}()

		// Should complete within reasonable time
		select {
		case <-done:
			// Good - completed
		case <-time.After(5 * time.Second):
			t.Fatal("deadlock detected: lock cycles did not complete")
		}
	})
}

// FuzzLock_IndependentPaths verifies locks on different paths don't interfere.
func FuzzLock_IndependentPaths(f *testing.F) {
	// Boundary paths (tests clamping)
	f.Add(int64(0), 2)  // Minimum
	f.Add(int64(1), 10) // Maximum
	f.Add(int64(2), 1)  // Below min (clamped to 2)
	f.Add(int64(3), 20) // Above max (clamped to 10)

	// Seed boundaries
	f.Add(int64(-1), 5)
	f.Add(int64(math.MaxInt64), 5)

	f.Fuzz(func(t *testing.T, seed int64, numPaths int) {
		if numPaths < 2 {
			numPaths = 2
		}

		if numPaths > 10 {
			numPaths = 10
		}

		fs := NewReal()
		locker := NewLocker(fs)
		dir := t.TempDir()

		// Create paths
		paths := make([]string, numPaths)
		for i := range numPaths {
			paths[i] = filepath.Join(dir, fmt.Sprintf("file%d.txt", i))
		}

		// Acquire ALL locks simultaneously - should not block
		locks := make([]*Lock, numPaths)
		done := make(chan struct{})

		go func() {
			for i, path := range paths {
				lock, err := locker.Lock(path, testTimeout)
				if err != nil {
					return
				}

				locks[i] = lock
			}

			close(done)
		}()

		// Should acquire all locks quickly (no blocking)
		select {
		case <-done:
			// Good - all acquired
		case <-time.After(2 * time.Second):
			t.Fatal("independent paths should not block each other")
		}

		// Cleanup
		for _, lock := range locks {
			if lock != nil {
				lock.Close()
			}
		}
	})
}
